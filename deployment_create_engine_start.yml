---
- name: Create a deployment
  hosts: controlhub
  remote_user: susannah
  
  # CREATE A DEPLOYMENT AND ENABLE IT in the DataOps Control Hub

  vars:
    # REQUIRED SETTINGS
    # ENVIRONMENT VARIABLES
    # Set your CRED_ID and CRED_TOKEN here or set environment variables CRED_ID and CRED_TOKEN
    CRED_TOKEN: "{{ lookup('env', 'CRED_TOKEN') | default('YOU MUST SET YOUR CRED_TOKEN', true) }}"
    CRED_ID: "{{ lookup('env','CRED_ID')|default('YOU MUST SET YOUR CRED_ID', true) }}"
    STREAMSETS_SCH_URL: "{{ lookup('env', 'STREAMSETS_SCH_URL') | default('http://localhost:18631', true) }}"
    ENVIRONMENT_ID: "{{ lookup('env', 'STREAMSETS_ENV_ID') | default('Environment ID must be configured.', true) }}"

    #  CONFIGURATIONS WITH DEFAULT VALUES
    ENGINE_TYPE: "TF"   # DC or TF TODO lookup from env and allow a default DC
    ENGINE_VERSION: "4.1.0" # TODO lookup from env and allow a default DC
    INSTALL_TYPE: "TARBALL"   # DOCKER or TARBALL # TODO lookup env and default
    # BUILD_NUMBER: "Released"  # Released or a number # TODO lookup env and default
    BUILD_NUMBER: "9"  # Released or a number # TODO lookup env and default
    SCALA_BINARY_VERSION: "2.12" # "2.11" or "2.12" # TODO lookup env and default

    STREAMSETS_DOWNLOAD_DIR: "{{ lookup('env', 'STREAMSETS_DOWNLOAD_DIR') | default('/tmp/streamsets_download', true) }}"
    STREAMSETS_INSTALL_DIR: "{{ lookup('env', 'STREAMSETS_INSTALL_DIR') | default('/tmp/streamsets_install', true) }}"

    # NEW_DEPLOYMENT_NAME: "New_Deployment_Name"
    NEW_DEPLOYMENT_NAME_BASE: "New_Deployment"

    # OPTIONAL SETTINGS:
    #   DEPLOYMENT_TAGS
    #   ENGINE_TAGS

    DEPLOYMENT_HTTP_HEADERS_DICT: {
      "X-Requested-By":"User",
      "X-SS-REST-CALL":"true",
      "X-SS-App-Auth-Token":"{{CRED_TOKEN}}",
      "X-SS-App-Component-Id":"{{CRED_ID}}",
      "Content-type":"application/json",
    }

    ADVANCED_HTTP_HEADERS_DICT: {
      "X-Requested-By":"User",
      "X-SS-REST-CALL":"true",
      "X-SS-App-Auth-Token":"{{CRED_TOKEN}}",
      "X-SS-App-Component-Id":"{{CRED_ID}}",
    }

    ADVANCED_HTTP_HEADERS: >-
      --header "X-Requested-By:User"
      --header "X-SS-REST-CALL:true"
      --header "X-SS-App-Auth-Token:{{CRED_TOKEN}}"
      --header "X-SS-App-Component-Id:{{CRED_ID}}"

    CREATE_DEPLOYMENT_URL: >-
      {{ STREAMSETS_SCH_URL }}/provisioning/rest/v1/csp/deployments

    UPDATE_DEPLOYMENT_URL: >-
      {{ STREAMSETS_SCH_URL }}/provisioning/rest/v1/csp/deployment/{{ DEPLOYMENT_ID }}

    COMPLETE_DEPLOYMENT_URL: >-
      {{ STREAMSETS_SCH_URL }}/provisioning/rest/v1/csp/deployment/{{ DEPLOYMENT_ID }}?complete=true&processIfEnabled=true

    START_DEPLOYMENT_URL: >-
      {{ STREAMSETS_SCH_URL }}/provisioning/rest/v1/csp/deployment/{{ DEPLOYMENT_ID }}/start

    UPDATE_ADVANCED_CONFIGURATION_URL: >-
      {{ STREAMSETS_SCH_URL }}/provisioning/rest/v1/csp/deployment/{{ DEPLOYMENT_ID }}/advancedConfiguration

    CREATE_DEPLOYMENT_BINARY_DATA: >-
      {"name": "{{ NEW_DEPLOYMENT_NAME }}",
      "engineType": "{{ ENGINE_TYPE }}",
      "engineVersion": "{{ ENGINE_VERSION }}",
      "engineVersionId": "{{ ENGINE_VERSION_ID }}",
      "envId": "{{ ENVIRONMENT_ID }}",
      "rawDeploymentTags": [],
      "type": "SELF" }


    GET_INSTALL_COMMAND_URL: >-
      {{ STREAMSETS_SCH_URL }}/provisioning/rest/v1/csp/deployment/self/{{ DEPLOYMENT_ID }}/installCommand?installMechanism=BACKGROUND

  tasks:

    # --------------------------------------------------------------------------------

    - name: SECTION 0 - Set deployment name, set Scala version, create engine ID, assert that required env vars are set
      set_fact:
        NEW_DEPLOYMENT_NAME: "{{ NEW_DEPLOYMENT_NAME | default( NEW_DEPLOYMENT_NAME_BASE + '_' + ENGINE_TYPE + '_' + ENGINE_VERSION ) }}"

    - name: STEP 0.x set SCALA BINARY version to be empty string for engine
      set_fact:
        SCALA_BINARY_VERSION: ""
      when: "ENGINE_TYPE=='DC'"

    - name: STEP 0.x Create ENGINE_VERSION_ID
      set_fact:
        ENGINE_VERSION_ID:  "{{ENGINE_TYPE}}:{{ENGINE_VERSION}}:{{SCALA_BINARY_VERSION}}:{{BUILD_NUMBER}}"

    - name: STEP 0.x - Add the Scala version if set (only applicable to Transformer)
      set_fact:
        NEW_DEPLOYMENT_NAME: "{{ NEW_DEPLOYMENT_NAME + '_' + SCALA_BINARY_VERSION }}"
      when: "ENGINE_TYPE=='TF'"

    - name: STEP 0.x Add Scala binary version to the deployment creation
      set_fact:
        CREATE_DEPLOYMENT_BINARY_DATA: "{{ CREATE_DEPLOYMENT_BINARY_DATA | default({}) | combine ({ item.key : item.value }) }}"
      with_items:
        - { 'key': 'scalaBinaryVersion' , 'value': "{{ SCALA_BINARY_VERSION }}" }

    - name: STEP 0.x Verify required env vars are set
      assert:
        that:
          - CRED_TOKEN is defined
          - CRED_ID is defined
          - STREAMSETS_SCH_URL is defined
          - INSTALL_TYPE is defined
          - ENVIRONMENT_ID is defined
          - ENVIRONMENT_ID != "Environment ID must be configured."
        fail_msg: "At least one required environment variable was not set. Did you defined an environment ID (STREAMSETS_ENV_ID)?"
   # --------------------------------------------------------------------------------

   # --------------------------------------------------------------------------------
    - name: SECTION 1 - CREATE DEPLOYMENT STEP 1.1
      uri:
        url: "{{ CREATE_DEPLOYMENT_URL }}"
        method: PUT
        return_content: yes
        status_code: 201, 200
        headers: "{{ DEPLOYMENT_HTTP_HEADERS_DICT }}"
        body_format: json
        body: "{{ CREATE_DEPLOYMENT_BINARY_DATA }}"
      register: json_response

    - name: STEP 1.2 Extract JSON deployment_record
      set_fact:
        deployment_record: "{{ json_response.content }}"

    - name: STEP 1.3 Extract Deployment ID from response
      set_fact:
         DEPLOYMENT_ID: "{{ deployment_record.id }}"
    # --------------------------------------------------------------------------------


    # --------------------------------------------------------------------------------
    - name: SECTION 2 - READ STAGELIBRARIES FILE, STEP 2.1
      set_fact:
        ADVANCED_CONFIG_PATH: '{{ ENGINE_TYPE }}/{{ ENGINE_VERSION }}'
      when: "ENGINE_TYPE=='DC'"

    - name: STEP 2.2 - Set path to the stagelibs.yml file
      set_fact:
        ADVANCED_CONFIG_PATH: '{{ ENGINE_TYPE }}/{{ ENGINE_VERSION }}/{{ SCALA_BINARY_VERSION }}'
      when: "ENGINE_TYPE=='TF'"

    - name: STEP 2.x - Add onto the path to the stagelibs.yml file
      set_fact:
        STAGELIBS_PATH: "{{ ADVANCED_CONFIG_PATH }}/stagelibs.yml"

    - name: STEP 2.x - Read stagelibraries file
      set_fact:
        STAGELIBS: "{{ lookup('file', '{{ STAGELIBS_PATH }}').splitlines() }}"
    # --------------------------------------------------------------------------------


    # --------------------------------------------------------------------------------
    - name: SECTION 3 - UPDATE THE STAGE LIBRARIES - STEP 3.1 Set the stageLibs field in the deployment_record
      set_fact:
         deployment_record: "{{ deployment_record|combine({'engineConfiguration': {'stageLibs': STAGELIBS }}, recursive=True) }}"

    - name: STEP 3.x Update the install type
      set_fact:
        deployment_record: "{{ deployment_record|combine({'installType': INSTALL_TYPE }, recursive=True) }}"
    # --------------------------------------------------------------------------------


    # --------------------------------------------------------------------------------
    - name: SECTION 4  - SEND UPDATE DEPLOYMENT STAGE LIBRARIES COMMAND
      uri:
        url: "{{ UPDATE_DEPLOYMENT_URL }}"
        method: POST
        return_content: yes
        status_code: 201, 200
        headers: "{{ DEPLOYMENT_HTTP_HEADERS_DICT }}"
        body_format: json
        body: "{{ deployment_record }}"
      register: json_response

    - name: STEP 4.2 Extract JSON deployment_record
      set_fact:
        deployment_record_updated: "{{ json_response.content }}"
    # --------------------------------------------------------------------------------


   # --------------------------------------------------------------------------------
    - name: SECTION 4.5  - UPDATE ADVANCED CONFIGURATIONS - STEP 4.x Find files in the advanced configuration folder named .properties or .policy
      find:
        paths: "{{ playbook_dir }}/{{ ADVANCED_CONFIG_PATH }}/advanced_config/"
        patterns: '*.properties,*policy'
        recurse: false
      register: output

    - name: STEP 4.x Extract the file names for advanced configuration files
      set_fact:
        advanced_config_filenames:  "{{ advanced_config_filenames | default([]) + [ item.path ] }}"
      loop: "{{ output.files }}"

    - name: STEP 4.x Update each advanced configuration file
      include_tasks: advanced_config_files_tasks.yml
      loop: "{{ advanced_config_filenames }}"

    - name: STEP 4.x Extract JSON deployment_record
      set_fact:
         deployment_record_updated: "{{ curlResult.stdout | from_json }}"
    # --------------------------------------------------------------------------------


    # --------------------------------------------------------------------------------
    - name: SECTION 5 - SET THE DEPLOYMENT TO 'COMPLETE' - STEP 5.x SEND UPDATE TO COMPLETE DEPLOYMENT
      uri:
        url: "{{ COMPLETE_DEPLOYMENT_URL }}"
        method: POST
        return_content: yes
        status_code: 201, 200
        headers: "{{ DEPLOYMENT_HTTP_HEADERS_DICT }}"
        body_format: json
        body: "{{ deployment_record_updated }}"
      register: json_response

    - name: STEP 5.2 Extract JSON deployment_record
      set_fact:
        deployment_record_updated: "{{ json_response.content }}"
     # --------------------------------------------------------------------------------


    # --------------------------------------------------------------------------------
    - name: SECTION 6 - START (ENABLE) DEPLOYMENT - STEP 6.x the start deployment curl command string
      uri:
        url: "{{ START_DEPLOYMENT_URL }}"
        method: POST
        return_content: yes
        status_code: 201, 200
        headers: "{{ DEPLOYMENT_HTTP_HEADERS_DICT }}"
        body_format: json
      register: json_response
     # --------------------------------------------------------------------------------


     # --------------------------------------------------------------------------------
    - name: SECTION 7 - STEP 7.1 Check status of the deployment
      set_fact:
        deployment_record_final: "{{ json_response.content }}"

    - name: STEP 7.x Check for ENBABLED state
      assert:
        that: "deployment_record_final.state == 'ENABLED'"
        fail_msg: "FAIL: expected deployment in an ENABLED state."
      ignore_errors: yes

    - name: STEP 7.x for OK status
      assert:
        that: "deployment_record_final.status == 'OK'"
        fail_msg: "FAIL: expected deployment in an OK status."
      ignore_errors: yes
   # --------------------------------------------------------------------------------


   # --------------------------------------------------------------------------------
    - name: SECTION 8 - START AN ENGINE ON THE NEW DEPLOYMENT
      uri:
        url: "{{ GET_INSTALL_COMMAND_URL }}"
        method: GET
        return_content: yes
        status_code: 200
        headers: "{{ DEPLOYMENT_HTTP_HEADERS_DICT }}"
        body_format: json
      register: installCommand

    - name: STEP 8.x - Run retrieved install command for TARBALL installations
      ansible.builtin.shell: "{{ installCommand.content }} --no-prompt --download-dir={{ STREAMSETS_DOWNLOAD_DIR }} --install-dir={{ STREAMSETS_INSTALL_DIR }} --background"
      when: "INSTALL_TYPE=='TARBALL'"
      register: scriptResult
      ignore_errors: false

    - name: STEP 8.x - Run retrieved install command for DOCKER installations
      ansible.builtin.shell: "{{ installCommand.content }}"
      when: "INSTALL_TYPE=='DOCKER'"
      register: scriptResult
      ignore_errors: false
    # --------------------------------------------------------------------------------
